/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : IEE1.c
**     Project     : MechGauge
**     Processor   : MC9S12ZVH128VLL
**     Component   : IntEEPROM
**     Version     : Component 02.218, Driver 01.28, CPU db: 3.00.000
**     Compiler    : CodeWarrior HCS12Z C Compiler
**     Date/Time   : 2020-05-26, 17:51, # CodeGen: 24
**     Abstract    :
**         This device "IntEEPROM" implements internal EEPROM
**     Comment     :
**         The EEPROM array is organized as rows of word (2 bytes), the EEPROM block's
**         erase sector size is 2 rows (2 words). Therefore it is preferable
**         to use word aligned data for writting - methods SetWord and SetLong -
**         with word aligned address.
**         Driver expects that all security options of EEPROM are disabled.
**         If some security option is enabled methods performing write
**         operation (such as SetWord) can return error.
**     Settings    :
**         Initialization:
**              Wait in methods        : Enabled
**
**     Contents    :
**         SetByte     - byte IEE1_SetByte(IEE1_TAddress Addr, byte Data);
**         GetByte     - byte IEE1_GetByte(IEE1_TAddress Addr, byte *Data);
**         SetWord     - byte IEE1_SetWord(IEE1_TAddress Addr, word Data);
**         GetWord     - byte IEE1_GetWord(IEE1_TAddress Addr, word *Data);
**         SetLong     - byte IEE1_SetLong(IEE1_TAddress Addr, dword Data);
**         GetLong     - byte IEE1_GetLong(IEE1_TAddress Addr, dword *Data);
**         Busy        - bool IEE1_Busy(void);
**         EraseEeprom - byte IEE1_EraseEeprom(IEE1_TAddress Addr);
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file IEE1.c
** @version 01.28
** @brief
**         This device "IntEEPROM" implements internal EEPROM
*/         
/*!
**  @addtogroup IEE1_module IEE1 module documentation
**  @{
*/         


/* MODULE IEE1. */

#include "Events.h"
#include "IEE1.h"

/* Internal type for addressing of the EEPROM. */
typedef const  word * IEE1_TAddress_;  /* Type of address to the EEPROM */

#pragma DATA_SEG IEE1_DATA             /* Select data segment "IEE1_DATA" */
#pragma CODE_SEG IEE1_CODE

/*lint -save  -e923 -e926 -e927 -e928 -e929 Disable MISRA rule (11.3,11.4) checking. */

static word BackupArray[0x02];         /* Array for backup data from erased sector */


/*
** ===================================================================
**     Method      :  BackupSector (component IntEEPROM)
**
**     Description :
**         The method backups the content of a sector being erased.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void BackupSector(IEE1_TAddress_ Addr, word From, word To)
{
  word i;

  for (i = From; i < To; i = i + 2U) {
    BackupArray[i/2U] = *(word *) (Addr + (i/2U)); /* Save one sector to RAM */
  }
}

/*
** ===================================================================
**     Method      :  WriteBlock (component IntEEPROM)
**
**     Description :
**         The method writes the block of data to EEPROM memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte WriteBlock(IEE1_TAddress Addr, word From, word To, const word* Data)
{
  byte err = 0U;
  word i;
  byte j;
  dword PhraseAddr;

  if(From == To) {
    return ERR_OK;
  }
  i = From;
  PhraseAddr = (dword)Addr;
  while(i < To) {
  /* FSTAT: ACCERR=1,FPVIOL=1 */
    FSTAT = 0x30U;                     /* Clear error flags */
    FCCOBIX = 5U;                      /* Five bytes will be loaded to FCCOBn registers */
    FCCOB0HI = 0x11U;                  /* Program D-Flash command */
    FCCOB0LO = (byte)(PhraseAddr >> 16U); /* High address word */
    FCCOB1 = (word)PhraseAddr;         /* Low address word */
    for(j = 0U; j < 4U; j++) {
      *((volatile word*)&FCCOB2 + j) = *((const word *)(Data + (i/2U))); /* Load new data */
      i += 2U;
      if(i >= To) {
        FCCOBIX = j + 2U;              /* Correct number of bytes written to FCCOBn*/
        break;
      }
    }
    if (i < To) {                      /* Write not last word */
      FSTAT = 0x80U;                   /* Clear flag command buffer empty */
    } else {                           /* Write last word */
      EnterCritical();
      FSTAT = 0x80U;                   /* Clear flag command buffer empty */
      FCNFG_CCIE = 1U;                 /* Enable interrupt */
      ExitCritical();
    }
    while (FSTAT_CCIF == 0U) {}        /* Wait to command complete */
    if ((FSTAT & 0x30U) != 0U) {       /* Is protection violation or acces error detected ? */
      FCNFG_CCIE = 0U;                 /* Disable interrupt */
      return ERR_NOTAVAIL;             /* If yes then error */
    }
    if (FSTAT_MGSTAT) {                /* Was attempt to write data to the given address errorneous? */
      err = 1U;                        /* If yes then mark an error */
    }
    PhraseAddr += 8U;
  }
  if(err != 0U) {
    FCNFG_CCIE = 0U;                   /* Disable interrupt */
    return ERR_VALUE;                  /* If yes then error */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  EraseSectorInternal (component IntEEPROM)
**
**     Description :
**         The method erase a specific sector.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte EraseSectorInternal(IEE1_TAddress Addr)
{
  if (FSTAT_CCIF == 0U) {              /* Is command complete ? */
    return ERR_BUSY;                   /* If yes then error */
  }
  /* FSTAT: ACCERR=1,FPVIOL=1 */
  FSTAT = 0x30U;                       /* Clear error flags */
  FCCOBIX = 1U;                        /* Two FCCOBn registers will be loaded */
  FCCOB0HI = 0x12U;                    /* Erase D-Flash sector command */
  FCCOB0LO = (byte)(((dword)Addr) >> 16); /* High address word */
  FCCOB1 = (word)(((dword)Addr) & 0xFFFFFFFEUL); /* Low address word aligned to word*/
  FSTAT = 0x80U;                       /* Clear flag command buffer empty */
  while (FSTAT_CCIF == 0U) {}          /* Wait to command complete */
  if ((FSTAT & 0x23U) != 0U) {         /* Is access error or other error detected ? */
    return ERR_NOTAVAIL;               /* If yes then error */
  }
  return ERR_OK;                       /* OK */
}
/*
** ===================================================================
**     Method      :  WriteWord (component IntEEPROM)
**
**     Description :
**         The method writes the word data to EEPROM memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte WriteWord(IEE1_TAddress AddrRow,word Data16)
{
  if (FSTAT_CCIF == 0U) {              /* Is previous command in process ? */
    return ERR_BUSY;                   /* If yes then error */
  }
  /* FSTAT: ACCERR=1,FPVIOL=1 */
  FSTAT = 0x30U;                       /* Clear error flags */
  FCCOBIX = 2U;                        /* Three FCCOBn registers will be loaded */
  FCCOB0HI = 0x11U;                    /* Program D-Flash command */
  FCCOB0LO = (byte)(((dword)AddrRow) >> 16); /* High address word */
  FCCOB1 = (word)((dword)AddrRow);     /* Low address word */
  FCCOB2 = Data16;                     /* Load new data */
  EnterCritical();
  FSTAT = 0x80U;                       /* Clear flag command complete */
  FCNFG_CCIE = 1U;                     /* Enable interrupt */
  ExitCritical();
  if ((FSTAT & 0x30U) != 0U) {         /* Is protection violation or acces error detected ? */
    FCNFG_CCIE = 0U;                   /* Disable interrupt */
    return ERR_NOTAVAIL;               /* If yes then error */
  }
  while (!FSTAT_CCIF) {}               /* Wait for command completition */
  if (FSTAT_MGSTAT) {                  /* Was attempt to write data to the given address errorneous? */
    FCNFG_CCIE = 0U;                   /* Disable interrupt */
    return ERR_VALUE;                  /* If yes then error */
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  IEE1_SetByte (component IntEEPROM)
**     Description :
**         This method writes a given byte to a specified address in
**         EEPROM. The method also sets address pointer for <SetActByte>
**         and <GetActByte> methods (applicable only if these methods
**         are enabled). The pointer is set to address passed as the
**         parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address to EEPROM
**         Data            - Data to write
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_SPEED - the component does not work
**                           in the active speed mode 
**                           - ERR_BUSY - device is busy 
**                           - ERR_VALUE - verification of written data
**                           failed (read value does not match with
**                           written value) 
**                           - ERR_NOTAVAIL - other device-specific
**                           error 
**                           - ERR_RANGE - parameter Addr is out of range
** ===================================================================
*/
byte IEE1_SetByte(IEE1_TAddress Addr,byte Data)
{
  byte err;
  word Data16;
  IEE1_TAddress SecAddr;               /* EEPROM Sector address */

  if(((dword)Addr < (dword)IEE1_AREA_START) || ((dword)Addr > (dword)IEE1_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if(!FSTAT_CCIF) {                    /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  SecAddr = (IEE1_TAddress)((dword)Addr & 0x00FFFFFEUL); /* Aligned word address */
  if (*((word *)(SecAddr)) == 0xFFFFU) { /* Is the word erased? */
    if (((dword)Addr) & 1U) {          /* Not Aligned word ? */
      return(WriteWord(SecAddr, ((*SecAddr) & 0xFF00U) | Data));
    } else {
      return(WriteWord(Addr, ((word)Data << 8) | (*(((byte *)Addr) + 1U)))); /* Aligned word ? */
    }
  } else {                             /* Is given address non-erased ? */
    SecAddr = (IEE1_TAddress)((dword)Addr & 0x00FFFFFCUL); /* Sector Aligned address */
    BackupSector(SecAddr, 0U, 0x04U);  /* Backup sector */
    Data16 = BackupArray[(((dword)Addr) % 0x04U) / 2U]; /* Store new data to backup array*/
    if (((dword)Addr) & 1U) {          /* Not Aligned word ? */
      Data16 = (Data16 & 0xFF00U) | Data;
    } else {
      Data16 = ((word)Data << 8) | (Data16 & 0xFFU);
    }
    BackupArray[(((dword)Addr) % 0x04U) / 2U] = Data16; /* Write new data to saved sector */
    err = EraseSectorInternal(Addr);   /* Erase sector */
    if(err != 0U) {
      return(err);                     /* Return error code if previous operation finished not correctly */
    }
    err = WriteBlock(SecAddr, 0U, 0x04U,BackupArray); /* Restore sector */
    return(err);
  }
}

/*
** ===================================================================
**     Method      :  IEE1_GetByte (component IntEEPROM)
**     Description :
**         This method reads a byte from a specified EEPROM address.
**         The method also sets address pointer for <SetActByte> and
**         <GetActByte> methods (applicable only if these methods are
**         enabled). The pointer is set to address passed as the
**         parameter.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - EEPROM Address
**       * Data            - A pointer to the returned 8-bit data
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_BUSY - device is busy 
**                           - ERR_RANGE - parameter Addr is out of range
** ===================================================================
*/
byte IEE1_GetByte(IEE1_TAddress Addr,byte *Data)
{
  if(((dword)Addr < (dword)IEE1_AREA_START) || ((dword)Addr > (dword)IEE1_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if(!FSTAT_CCIF) {                    /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  *Data = *((byte *)Addr);
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  IEE1_SetWord (component IntEEPROM)
**     Description :
**         This method writes a given word (2 bytes) to the specified
**         address in EEPROM. The method also sets address pointer for
**         <SetActByte> and <GetActByte> methods (applicable only if
**         these methods are enabled). The pointer is set to address
**         passed as the parameter + 1.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address to EEPROM
**         Data            - Data to write
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_SPEED - the component does not work
**                           in the active speed mode 
**                           - ERR_BUSY - device is busy 
**                           - ERR_VALUE - verification of written data
**                           failed (read value does not match with
**                           written value) 
**                           - ERR_NOTAVAIL - other device-specific
**                           error 
**                           - ERR_RANGE - selected address out of the
**                           selected address range
** ===================================================================
*/
byte IEE1_SetWord(IEE1_TAddress Addr,word Data)
{
  byte err;
  IEE1_TAddress SecAddr;               /* EEPROM Sector address */

  if(((dword)Addr < (dword)IEE1_AREA_START) || ((dword)Addr > (dword)IEE1_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if ((dword)Addr & 0x01U) {           /* Aligned address ? */
    return ERR_NOTAVAIL;
  }
  if(!FSTAT_CCIF) {                    /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  if (*(Addr) == 0xFFFFU) {            /* Is the word erased? */
      return(WriteWord(Addr, Data));
  } else {                             /* Is given address non-erased ? */
    SecAddr = (IEE1_TAddress)((dword)Addr & 0x00FFFFFCUL); /* Sector Aligned address */
    BackupSector(SecAddr, 0U, 0x04U);  /* Backup sector */
    BackupArray[(((dword)Addr) % 0x04U) / 2U] = Data; /* Write new data to saved sector */
    err = EraseSectorInternal(Addr);   /* Erase sector */
    if(err != 0U) {
      return(err);                     /* Return error code if previous operation finished not correctly */
    }
    err = WriteBlock(SecAddr, 0U, 0x04U,BackupArray); /* Restore sector */
    return(err);
  }
}

/*
** ===================================================================
**     Method      :  IEE1_GetWord (component IntEEPROM)
**     Description :
**         This method reads a word (2 bytes) from the specified EEPROM
**         address. The method also sets address pointer for
**         <SetActByte> and <GetActByte> methods (applicable only if
**         these methods are enabled). The pointer is set to address
**         passed as the parameter + 1.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address to EEPROM
**       * Data            - Pointer to returned 16-bit data
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_BUSY - device is busy 
**                           - ERR_RANGE - selected address out of the
**                           selected address range
** ===================================================================
*/
byte IEE1_GetWord(IEE1_TAddress Addr,word *Data)
{
  if(((dword)Addr < (dword)IEE1_AREA_START) || ((dword)Addr > (dword)IEE1_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if(!FSTAT_CCIF) {                    /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  *Data = *Addr;                       /* Return data from given address */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  IEE1_SetLong (component IntEEPROM)
**     Description :
**         This method writes a given long word (4 bytes) to the
**         specified address in EEPROM. The method also sets address
**         pointer for <SetActByte> and <GetActByte> methods
**         (applicable only if these methods are enabled). The pointer
**         is set to address passed as the parameter + 3.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address to EEPROM
**         Data            - Data to write
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_SPEED - the component does not work
**                           in the active speed mode 
**                           - ERR_BUSY - device is busy 
**                           - ERR_VALUE - verification of written data
**                           failed (read value does not match with
**                           written value) 
**                           - ERR_NOTAVAIL - other device-specific
**                           error 
**                           - ERR_RANGE - selected address out of the
**                           selected address range
** ===================================================================
*/
byte IEE1_SetLong(IEE1_TAddress Addr,dword Data)
{
  byte err;
  IEE1_TAddress SecAddr;               /* EEPROM Sector address */

  if(((dword)Addr < (dword)IEE1_AREA_START) || ((dword)Addr > (dword)IEE1_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if ((dword)Addr & 0x03U) {           /* Aligned address ? */
    return ERR_NOTAVAIL;
  }
  if(!FSTAT_CCIF) {                    /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  if (*((dword *)Addr) == 0xFFFFFFFFUL) { /* Is the dword erased? */
    err = WriteBlock(Addr, 0U, 0x04U,((word*)&Data)); /* Write dword */
  } else {                             /* Is given address non-erased ? */
    SecAddr = (IEE1_TAddress)((dword)Addr & 0x00FFFFFCUL); /* Sector Aligned address */
    BackupSector(SecAddr, 0U, 0x04U);  /* Backup sector */
    BackupArray[(((dword)Addr) % 0x04U) / 2U] = (word)(Data >> 16); /* Write new data to saved sector */
    BackupArray[((((dword)Addr) % 0x04U) / 2U) + 1U] = (word)(Data); /* Write new data to saved sector */
    err = EraseSectorInternal(Addr);   /* Erase sector */
    if(err != 0U) {
      return(err);                     /* Return error code if previous operation finished not correctly */
    }
    err = WriteBlock(SecAddr, 0U, 0x04U,BackupArray); /* Restore sector */
  }
  return(err);
}

/*
** ===================================================================
**     Method      :  IEE1_GetLong (component IntEEPROM)
**     Description :
**         This method reads a long word (4 bytes) from the specified
**         EEPROM address. The method also sets address pointer for
**         <SetActByte> and <GetActByte> methods (applicable only if
**         these methods are enabled). The pointer is set to address
**         passed as the parameter + 3.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Address to EEPROM
**       * Data            - A pointer to the returned 32-bit data
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_BUSY - device is busy 
**                           - ERR_RANGE - selected address out of the
**                           selected address range
** ===================================================================
*/
byte IEE1_GetLong(IEE1_TAddress Addr,dword *Data)
{
  if(((dword)Addr < (dword)IEE1_AREA_START) || ((dword)Addr > (dword)IEE1_AREA_END)) { /* Is given address out of EEPROM area array ? */
    return ERR_RANGE;                  /* If yes then error */
  }
  if(!FSTAT_CCIF) {                    /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  *Data = *( dword *)(Addr);           /* Return data from given address */
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  IEE1_Busy (component IntEEPROM)
**     Description :
**         Method returns the status of EEPROM device.
**     Parameters  : None
**     Returns     :
**         ---             -   - <true> if EEPROM is busy 
**                           - <false> if EEPROM is ready
** ===================================================================
*/
/*
bool IEE1_Busy(void)

**      This method is implemented as macro. See IEE1.h file.      **
*/

/*lint -save  -e818 Disable MISRA rule (16.7) checking. */
/*
** ===================================================================
**     Method      :  IEE1_EraseEeprom (component IntEEPROM)
**     Description :
**         The method mass erases all EEPROM memory. The method also
**         sets address pointer for <SetActByte> and <GetActByte>
**         methods (applicable only if these methods are enabled). The
**         pointer is set to address passed as the parameter - 1.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Addr            - Pass any valid EEPROM address. EEPROM
**                           module in some CPU families don't require
**                           address for mass erase, then the parameter
**                           is ignored.
**     Returns     :
**         ---             - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_SPEED - the component does not work
**                           in the active speed mode 
**                           - ERR_BUSY - device is busy 
**                           - ERR_NOTAVAIL - other device-specific error
** ===================================================================
*/
byte IEE1_EraseEeprom(IEE1_TAddress Addr)
{
  word i;
  IEE1_TAddress SectAddr;

  if(!FSTAT_CCIF) {                    /* Is reading from EEPROM possible? */
    return ERR_BUSY;                   /* If no then error */
  }
  SectAddr = (IEE1_TAddress)0x00100000UL; /* D-Flash beginning */
  for(i = 0U;i < 0x0400U;i++) {
    /* FSTAT: ACCERR=1,FPVIOL=1 */
    FSTAT = 0x30U;                     /* Clear error flags */
    FCCOBIX = 1U;                      /* Two FCCOBn registers will be loaded */
    FCCOB0HI = 0x12U;                  /* Erase D-Flash sector command */
    FCCOB0LO = (byte)(((dword)SectAddr) >> 16); /* High address word */
    FCCOB1 = (word)(((dword)SectAddr) & 0xFFFFFFFEUL); /* Low address word aligned to word*/
    if(i < 0x03FFU) {                  /* If it is not the last sector */
      FSTAT = 0x80U;                   /* Clear flag command complete */
    } else {
      EnterCritical();
      FSTAT = 0x80U;                   /* Clear flag command complete */
      FCNFG_CCIE = 1U;                 /* Enable interrupt */
      ExitCritical();
    }
    if (FSTAT_ACCERR) {                /* Is access error detected ? */
      FCNFG_CCIE = 0U;                 /* Disable interrupt */
      return ERR_NOTAVAIL;             /* If yes then error */
    }
    if(i < 0x03FFU) {                  /* If it is not the last sector */
      while (!FSTAT_CCIF) {}           /* then wait for command completition */
      if (FSTAT_MGSTAT) {              /* Is an error detected ? */
        FCNFG_CCIE = 0U;               /* Disable interrupt */
        return ERR_NOTAVAIL;           /* If yes then error */
      }
    }
    SectAddr = (IEE1_TAddress)((dword)SectAddr + 0x04U); /* Next sector */
  }
  while (!FSTAT_CCIF) {}               /* If yes then wait for command completition */
  if (FSTAT_MGSTAT) {                  /* Is an error detected ? */
    FCNFG_CCIE = 0U;                   /* Disable interrupt */
    return ERR_NOTAVAIL;               /* If yes then error */
  }
  return ERR_OK;                       /* OK */
}
/*lint -restore Enable MISRA rule (16.7) checking. */

/*
** ===================================================================
**     Method      :  IEE1_Init (component IntEEPROM)
**
**     Description :
**         Initializes the associated peripheral(s) and the component 
**         internal variables. The method is called automatically as a 
**         part of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void IEE1_Init(void)
{
  FCLKDIV = 0x17U;                     /* Set up Clock Divider Register */
}

/*
** ===================================================================
**     Method      :  IEE1_Interrupt (component IntEEPROM)
**
**     Description :
**         The method services the interrupt of the selected peripheral(s)
**         and eventually invokes event(s) of the component.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#pragma CODE_SEG __NEAR_SEG NON_BANKED
ISR(IEE1_Interrupt)
{
  FCNFG &= 0x3FU;
  IEE1_OnWriteEnd();                   /* Invoke user event */
}

#pragma CODE_SEG IEE1_CODE
/*lint -restore Enable MISRA rule (11.3,11.4) checking. */

/* END IEE1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale HCS12Z series of microcontrollers.
**
** ###################################################################
*/
